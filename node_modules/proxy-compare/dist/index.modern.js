const e=Symbol(),t=Symbol(),r=Symbol(),n=Object.getPrototypeOf,o=new WeakMap,s=e=>e&&(o.has(e)?o.get(e):n(e)===Object.prototype||n(e)===Array.prototype),c=e=>"object"==typeof e&&null!==e,i=(n,o)=>{let s=!1;const c=(t,r,o)=>{if(!s){let s=t.a.get(n);s||(s=new Set,t.a.set(n,s)),o&&s.has(e)||s.add(r)}},i={f:o,get(e,t){return t===r?n:(c(this,t),a(e[t],this.a,this.c))},has(e,r){return r===t?(s=!0,this.a.delete(n),!0):(c(this,r),r in e)},getOwnPropertyDescriptor(e,t){return c(this,t,!0),Object.getOwnPropertyDescriptor(e,t)},ownKeys(t){return c(this,e),Reflect.ownKeys(t)}};return o&&(i.set=i.deleteProperty=()=>!1),i},a=(e,t,o)=>{if(!s(e))return e;const c=e[r]||e,a=(e=>Object.isFrozen(e)||Object.values(Object.getOwnPropertyDescriptors(e)).some(e=>!e.writable))(c);let l=o&&o.get(c);return l&&l.f===a||(l=i(c,a),l.p=new Proxy(a?(e=>{if(Array.isArray(e))return Array.from(e);const t=Object.getOwnPropertyDescriptors(e);return Object.values(t).forEach(e=>{e.configurable=!0}),Object.create(n(e),t)})(c):c,l),o&&o.set(c,l)),l.a=t,l.c=o,l.p},l=(e,t)=>{const r=Reflect.ownKeys(e),n=Reflect.ownKeys(t);return r.length!==n.length||r.some((e,t)=>e!==n[t])},u=(t,r,n,o)=>{if(Object.is(t,r))return!1;if(!c(t)||!c(r))return!0;const s=n.get(t);if(!s)return!0;if(o){const e=o.get(t);if(e&&e.n===r)return e.g;o.set(t,{n:r,g:!1})}let i=null;for(const c of s){const s=c===e?l(t,r):u(t[c],r[c],n,o);if(!0!==s&&!1!==s||(i=s),i)break}return null===i&&(i=!0),o&&o.set(t,{n:r,g:i}),i},f=e=>!!s(e)&&t in e,y=e=>s(e)&&e[r]||null,p=(e,t=!0)=>{o.set(e,t)},g=(e,t)=>{const r=[],n=new WeakSet,o=(e,s)=>{if(n.has(e))return;c(e)&&n.add(e);const i=t.get(e);i?i.forEach(t=>{o(e[t],s?[...s,t]:[t])}):s&&r.push(s)};return o(e),r};export{g as affectedToPathList,a as createProxy,y as getUntracked,u as isChanged,p as markToTrack,f as trackMemo};
//# sourceMappingURL=index.modern.mjs.map
